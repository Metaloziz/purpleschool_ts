## 1. урок

    TS устанавливается отдельно. 

npm i -g typescript

    Если нужно проверить его наличие можно ввести:

tsc --help

    Инициализация минимально tsconfig:

tsc -- init

## 2. урок

    Сущевтвует явное и не явное приведение типов. Проверка типов происходит 
    только на уровне TS кода, когда он компилируется в JS никакоq типизации не 
    существует. Копиляция файла ts в js:

tsc

## 3. урок

    В файлу tsconfig можно настраивать разыне параметры TS. Например можно 
    отключить ошибку на переменные с типом any

"noImplicitAny": false

    Выброс ошибок

throw new Error('!!!!!')

    JS динамически типизированный язык, TS статически. т.е. в первом мы можем менять
    тип переменной, а во втором нет

## 4. урок

    В функцию которая принимает объект, можно передавать более широкие объекты, 
    главное наличие обязательных для функции ключей.

## 5. урок "Массивы"

    Для итерации по массиву 

for (const number of arr) { console.log(number)
}

    Для итерации по по ключам объекта 

for (const objKey in obj) { console.log(objKey)
}

## 6. урок "Tuples"

const skill: [number, string] = [1, 'power']

    это просто чёткое описание массива. Например, в этом только два элемента

const skill2: [number, string, ...boolean[]] = [1, 'power', true, false, false]

    Оказывается спред оператор применим к типам.

## 7. урок "Readonly"

    Например у массивов в принцепе убират методы, которые могу его мутироват 
    (push(), pop(), ... )

## 8. урок "Enum"

    Енам лучше создавать с одинаковым типом данных. Значение ключа может быть вычисляемым. 
    Enum после компиляции превращается в самовызывающуюся функцию. Если объявить enum через 
    слово const то после компиляции не будет функции инициализации для enum, а во всех 
    местах где используется enum появятся константы.

## 9. урок "Union"

    arg: string | number[]

    Если в if_else проверять union тип, то после нам доступны ключи именно того 
    типа на который проверяли.

## 10. урок "Literal Types"

    Пример литерального типа:
    let a: 'post' | 'get' = 'get'

## 11. урок "Type Aliases"

    Когда мы тип присваиваем переменной объявленной через type, то это и есть 
    Alias type

## 12. урок "Interfaces"

    1. Это всегда объект, он не может быть Literal типом или примитивами
    2. Расширяемый, т.е. просто можно дописывать ключи после инициализации.
    3. Чтобы объединить типы нужно использовать extends вместо &.

## 13. урок "Types или Interfaces?"

    При использовании классов лучше использовать Interfaces, а Types чаще 
    используется для примитивов.

## 14. урок "Optional"

    Опwиональность key?: number ключа не эквивалента записи key: number | 
    undefined

## 15. урок "Void"

    Мы можем указать возвращаемое значение в фунекции как void - это буде значить,
    что возвращаемое значение из функции игнорируется т.е. оно может быть или не быть

## 16. урок "Unknown"

    В отличии от any этот тип не позволяет обращаться к методам объекта.Ближайшее где можно использовать - заглушка в ответе сервера. Т.е. позже этот тим нужно уточнить. 

## 17. урок "Never"

    Тип функций которые выбрасывают ошибку т.е. у них нету ни явноного ни не явного return 
