## 1. урок

    TS устанавливается отдельно. 

npm i -g typescript

    Если нужно проверить его наличие можно ввести:

tsc --help

    Инициализация минимально tsconfig:

tsc -- init

## 2. урок

    Сущевтвует явное и не явное приведение типов. Проверка типов происходит 
    только на уровне TS кода, когда он компилируется в JS никакоq типизации не 
    существует. Копиляция файла ts в js:

tsc

## 3. урок

    В файлу tsconfig можно настраивать разыне параметры TS. Например можно 
    отключить ошибку на переменные с типом any

"noImplicitAny": false

    Выброс ошибок

throw new Error('!!!!!')

    JS динамически типизированный язык, TS статически. т.е. в первом мы можем менять
    тип переменной, а во втором нет

## 4. урок

    В функцию которая принимает объект, можно передавать более широкие объекты, 
    главное наличие обязательных для функции ключей.

## 5. урок "Массивы"

    Для итерации по массиву 

for (const number of arr) { console.log(number)
}

    Для итерации по по ключам объекта 

for (const objKey in obj) { console.log(objKey)
}

## 6. урок "Tuples"

const skill: [number, string] = [1, 'power']

    это просто чёткое описание массива. Например, в этом только два элемента

const skill2: [number, string, ...boolean[]] = [1, 'power', true, false, false]

    Оказывается спред оператор применим к типам.

## 7. урок "Readonly"

    Например у массивов в принцепе убират методы, которые могу его мутироват 
    (push(), pop(), ... )

## 8. урок "Enum"

    Енам лучше создавать с одинаковым типом данных. Значение ключа может быть вычисляемым. 
    Enum после компиляции превращается в самовызывающуюся функцию. Если объявить enum через 
    слово const то после компиляции не будет функции инициализации для enum, а во всех 
    местах где используется enum появятся константы.

## 9. урок "Union"

    arg: string | number[]

    Если в if_else проверять union тип, то после нам доступны ключи именно того 
    типа на который проверяли.

## 10. урок "Literal Types"

    Пример литерального типа:
    let a: 'post' | 'get' = 'get'

## 11. урок "Type Aliases"

    Когда мы тип присваиваем переменной объявленной через type, то это и есть 
    Alias type

## 12. урок "Interfaces"

    1. Это всегда объект, он не может быть Literal типом или примитивами
    2. Расширяемый, т.е. просто можно дописывать ключи после инициализации.
    3. Чтобы объединить типы нужно использовать extends вместо &.

## 13. урок "Types или Interfaces?"

    При использовании классов лучше использовать Interfaces, а Types чаще 
    используется для примитивов.

## 14. урок "Optional"

    Опwиональность key?: number ключа не эквивалента записи key: number | 
    undefined

## 15. урок "Void"

    Мы можем указать возвращаемое значение в фунекции как void - это буде значить,
    что возвращаемое значение из функции игнорируется т.е. оно может быть или не быть

## 16. урок "Unknown"

    В отличии от any этот тип не позволяет обращаться к методам объекта.Ближайшее где можно использовать - заглушка в ответе сервера. Т.е. позже этот тим нужно уточнить. 

## 17. урок "Never"

    Тип функций которые выбрасывают ошибку т.е. у них нету ни явноного ни не явного return 

## 18. урок "Null"

    null это осознанное отсутствие данных.
    // "strictNullChecks": true, это правило запрещает присваивать null любым типам кроме null и any

## 19. урок "Приведение типов"

    При слиянии объектов разных типов не стоит использовать спред опретор, так как в JS объект может получиться шире чем нужно. Лучше использовать утилитные функции.

## 20. урок "Guard"

    функции использующиеся для проверки типов. Они возвращают type Guard т.е. они сужают тип. 

## 20. урок "Guard" Практика

## 21. урок "Class"

    Чтобы убрать обязательную инициализацию ключа в классе - в ts.config "strictPropertyInitialization": false,  

## 22. урок "constructor"

    просто функция внутри класса которой нельзя переприсвоить возвращаемое 
    значение но её можно перегрузить написав разные варианты аргументов в конструкторах выше.

## 23. урок "методы классов"

    Просто методы объекта, ты их знаешь.

## 24. getter setter

    set - это метод объекта в который мы забрасываем атрибут через присвоение.
    get - получение например приватного ключа, он защащет от изменений.
    Они не могут быть асинхронными.

## 25. implements

    Это расширение класса интерфесом. Добавление методов и свойств. Например, не вставлять в один объект и логирование и обработку ошибок и проверку API key, а создать все эти функции отдельно и потом имплементировать их в класс. Можно объединить сразу несколько интерфейсов.

## 26. Extends

    свойство override - указывается перед переопределяемым методом, чтобы в случае удаления исходного метода не создался новый с таким же именем

## 27. Композиция против наследования

    Наследоваться необходимо когда создаётся объект со свойственными ему методами 
    и свойствами, например, когда в User добавляем обработку возраста, но не 
    добавляем метод toLocalString.

    Композиция уменьшает связность - смотри пример кода.

## 28. Видимость свойств

    private - не наследуются
    protecetd - наследуются

    оба свойства не доступны напрямую в экземпляре класса

## 29. Статические свойства

    смотри код

## 30. Работа с this

    Смотри код.
    Со стрелочными функциями нужно быть аккуратно так как они не будут работать 
    при наследовании если их вызывать через super, нужно использовать this

## 31. Типизация this

    Из метода класса можно вернуть this, т.е. сам обект. Он так и типизируется :this
